# Firestore ORM - Development Guide

## Overview

This is a TypeScript-first ORM library for Firestore that supports both client-side (web) and server-side (admin) environments.

**Design Patterns:**
- **Document**: ActiveRecord pattern with automatic change tracking via Proxy
- **Collection**: Repository pattern for querying and managing document collections
- **Dual SDK Support**: Works seamlessly with both `firebase` (web) and `firebase-admin` (server)

## Project Structure

```
firestore-orm/
├── shared/              # Common utilities and types
│   ├── types.ts        # FirestoreKey, FirestoreData, FirestoreValue, etc.
│   ├── utils.ts        # deepEqual, parseKey, buildPath, newId, timeId
│   └── async-queue.ts  # AsyncQueue for real-time updates
├── web/                # Client-side implementation (firebase/firestore)
│   ├── document.ts     # FirestoreDocument for web
│   ├── collection.ts   # FirestoreCollection for web
│   ├── query.ts        # buildQuery helper
│   ├── batch.ts        # batchSave, batchDelete
│   ├── firestore.ts    # Firestore singleton
│   ├── types.ts        # Web-specific type exports
│   └── index.ts        # Public API exports
├── admin/              # Server-side implementation (firebase-admin/firestore)
│   ├── document.ts     # FirestoreDocument for admin
│   ├── collection.ts   # FirestoreCollection for admin
│   ├── query.ts        # buildQuery helper
│   ├── batch.ts        # batchSave, batchDelete
│   ├── firestore.ts    # Firestore singleton
│   ├── types.ts        # Admin-specific type exports
│   └── index.ts        # Public API exports
├── test/               # Test files (not published to npm)
│   ├── admin/test.ts   # Admin SDK integration tests
│   ├── web/test.ts     # Web SDK integration tests
│   └── firebase.json   # Emulator configuration
└── dist/               # Compiled output (generated by tsc)
```

## Core Implementation

### 1. FirestoreDocument (ActiveRecord Pattern)

**Files**:
- [admin/document.ts](admin/document.ts) - Admin SDK implementation
- [web/document.ts](web/document.ts) - Web SDK implementation

**Key Features:**
- **CRUD Operations**: `get()`, `save()`, `set()`, `update()`, `delete()`
- **Change Tracking**: Proxy-based automatic dirty detection
- **Real-time Updates**: `watch()` and `snapshot()` for live data
- **Serialization**: Automatic Date ↔ Timestamp conversion
- **Transaction Support**: All methods support `Transaction` and `WriteBatch`
- **Path Templates**: Flexible path building with placeholders like `users/{uid}`

**Usage Example:**
```typescript
class User extends FirestoreDocument<UserKey, UserData> {
  protected static pathTemplate = 'users/{uid}';

  static defaultData: UserData = {
    name: '',
    email: '',
    age: 0,
  };
}

const user = new User({ uid: 'user123' });
await user.get();
user.data.name = 'John';  // Change tracked via Proxy
await user.save();        // Only saves 'name' field (dirty tracking)
```

**Key Properties:**
- `data` - Proxied data object with change tracking
- `key` - Document key object
- `id` - Document ID
- `exist` - Whether document exists in Firestore
- `isNew` - Whether document hasn't been saved yet
- `isDirty` - Whether document has unsaved changes
- `isLoaded` - Whether document has been loaded from Firestore
- `reference` - Firestore DocumentReference

**Important Methods:**
- `get(transaction?, cache?)` - Load from Firestore
- `save(force?, transaction?)` - Auto-detects set vs update
- `set(data?, transaction?)` - Overwrite entire document
- `update(transaction?)` - Update only changed fields
- `delete(transaction?)` - Delete document
- `watch(callback?)` - Real-time listener (returns unsubscribe function)
- `snapshot()` - AsyncGenerator for real-time updates
- `toObject()` - Get deep copy of data

**Lifecycle Hooks:**
- `beforeSave()` - Called before save/set/update
- `afterSave()` - Called after successful save

### 2. FirestoreCollection (Repository Pattern)

**Files**:
- [admin/collection.ts](admin/collection.ts) - Admin SDK implementation
- [web/collection.ts](web/collection.ts) - Web SDK implementation

**Key Features:**
- **Query Support**: Full Firestore query API via `Condition` interface
- **CRUD Operations**: `get()`, `add()`, `set()`, `delete()`
- **Document Management**: Map-based document cache
- **Real-time Updates**: `watch()` and `snapshot()`
- **Batch Operations**: Via separate `batchSave()` and `batchDelete()` functions

**Usage Example:**
```typescript
const users = new FirestoreCollection<UserKey, UserData, User>(
  User,           // Document class constructor
  ['users'],      // Collection path as array
  {               // Optional query conditions
    where: [{ fieldPath: 'age', opStr: '>=', value: 20 }],
    orderBy: { fieldPath: 'age', directionStr: 'asc' },
    limit: 10
  }
);

await users.get();
for (const [id, user] of users.documents) {
  console.log(user.data);
}
```

**Key Properties:**
- `documents` - Map<string, Document> of loaded documents
- `reference` - Firestore CollectionReference
- `key` - Collection key (string array)
- `condition` - Query conditions
- `isLoaded` - Whether collection has been loaded

**Important Methods:**
- `get(cache?)` - Load documents matching query
- `add(data?, transaction?)` - Create document with auto-generated ID
- `set(id, data, transaction?)` - Create/update document with specific ID
- `delete(id, transaction?)` - Delete document by ID
- `save(transaction?)` - Save all dirty documents
- `first()` - Get first document
- `find(id)` - Find document by ID (cache only)
- `toArray()` - Convert documents to array
- `docs(force?)` - Get all documents as array
- `watch(callback)` - Real-time listener
- `unwatch()` - Cancel all listeners
- `snapshot()` - AsyncGenerator for real-time updates

### 3. Query Builder

**Files**:
- [admin/query.ts](admin/query.ts)
- [web/query.ts](web/query.ts)

**Condition Interface:**
```typescript
interface Condition {
  where?: Array<{
    fieldPath: string | FieldPath;
    opStr: WhereFilterOp;  // '==', '!=', '<', '<=', '>', '>=', 'array-contains', 'in', etc.
    value: unknown;
  }>;
  orderBy?: {
    fieldPath: string | FieldPath;
    directionStr?: 'asc' | 'desc';
  };
  limit?: number;
  limitToLast?: number;
  startAfter?: DocumentSnapshot;
  startAt?: DocumentSnapshot;
  endBefore?: DocumentSnapshot;
  endAt?: DocumentSnapshot;
}
```

### 4. Batch Operations

**Files**:
- [admin/batch.ts](admin/batch.ts)
- [web/batch.ts](web/batch.ts)

Batch operations are standalone functions that automatically chunk documents into batches of 500 (Firestore's limit):

```typescript
import { batchSave, batchDelete } from 'firestore-orm/admin';

// Save up to 1000s of documents
await batchSave([user1, user2, user3, /* ... */]);

// Delete multiple documents
await batchDelete([user1, user2, user3]);
```

### 5. Utility Functions

**File**: [shared/utils.ts](shared/utils.ts)

- `deepEqual(a, b)` - Deep equality comparison
- `parseKey(path, pathTemplate?)` - Parse Firestore path into key object
- `buildPath(key, pathTemplate?)` - Build Firestore path from key
- `newId(n?)` - Generate random alphanumeric ID
- `timeId(n?)` - Generate time-based sortable ID

### 6. AsyncQueue

**File**: [shared/async-queue.ts](shared/async-queue.ts)

Used internally for managing real-time snapshot streams in `snapshot()` AsyncGenerator methods.

## Design Considerations

### 1. Proxy-based Change Tracking

**Implementation**: Document data is wrapped in a Proxy that intercepts all property access and modifications.

**Benefits**:
- Automatic dirty tracking without manual marking
- Only changed fields are sent to Firestore on `save()`
- Clean API - developers don't need to think about change tracking

**Considerations**:
- Small performance overhead (negligible in practice)
- Nested objects are also proxied recursively

### 2. Path Templates

**Pattern**: `'users/{userId}/posts/{postId}'`

**Benefits**:
- Type-safe path construction
- Automatic path parsing and building
- Support for nested subcollections

**Implementation**:
- `buildPath()` replaces `{field}` placeholders with key values
- `parseKey()` extracts key fields from paths
- Validation ensures all required fields are present

### 3. Real-time Updates

**Two APIs**:
1. **`watch(callback)`** - Traditional callback-based listener
2. **`snapshot()`** - Modern AsyncGenerator for `for await` loops

**Memory Management**:
- `unwatch()` cancels all active listeners
- AsyncQueue handles cleanup on generator exit
- No memory leaks from forgotten listeners

### 4. Transaction & Batch Support

**All write operations accept optional `transaction` or `batch` parameters:**

```typescript
import { runTransaction } from 'firebase-admin/firestore';

await runTransaction(firestore(), async (transaction) => {
  const user = new User({ uid: 'user1' });
  await user.get(transaction);

  user.data.balance -= 100;
  await user.save(false, transaction);
});
```

### 5. Serialization

**Automatic conversions**:
- `Date` → `Timestamp` when writing
- `Timestamp` → `Date` when reading
- Nested objects handled recursively

**Customization via hooks**:
- Override `serializeValue()` for custom serialization
- Override `unserializeValue()` for custom deserialization

## Development Workflow

### Running Tests

1. **Start Firestore Emulator** (in one terminal):
```bash
npm run emulator
```

2. **Run Tests** (in another terminal):
```bash
npm run test:admin
npm run test:web  # Coming soon
```

### Building

```bash
npm run build   # Compile TypeScript
npm run clean   # Remove dist/
```

### Publishing

```bash
npm version patch  # or minor/major
npm publish
```

## Tips for AI Assistants

When working with this codebase:

1. **File structure**: `admin/` and `web/` have parallel implementations
2. **Type safety**: Always use proper generics `<Key, Data, Document>`
3. **Path templates**: Use `{field}` syntax, not `:field` or other formats
4. **defaultData**: Required static property on all Document classes
5. **Collection constructor**: First param is Document class, second is key array
6. **Batch limit**: Firestore has 500-document batch limit (handled automatically)
7. **instanceof issue**: When testing locally with `file:../..` dependencies, `instanceof DocumentReference` may fail due to module duplication. Use duct typing or ensure proper module resolution.

## References

### Important Files

- Core types: [shared/types.ts](shared/types.ts)
- Utils: [shared/utils.ts](shared/utils.ts)
- Admin Document: [admin/document.ts](admin/document.ts)
- Admin Collection: [admin/collection.ts](admin/collection.ts)
- Admin tests: [test/admin/test.ts](test/admin/test.ts)

### External Resources

- [Firestore Documentation](https://firebase.google.com/docs/firestore)
- [TypeScript Handbook](https://www.typescriptlang.org/docs/)
- [firebase npm package](https://www.npmjs.com/package/firebase)
- [firebase-admin npm package](https://www.npmjs.com/package/firebase-admin)
