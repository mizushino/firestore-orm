# Firestore ORM - Development Guide

## Overview

This is a TypeScript-first ORM library for Firestore that supports both client-side (web) and server-side (admin) environments.

**Design Patterns:**
- **Document**: ActiveRecord pattern with automatic change tracking via Proxy
- **Collection**: Repository pattern for querying and managing document collections
- **Dual SDK Support**: Works seamlessly with both `firebase` (web) and `firebase-admin` (server)

## Project Structure

```
firestore-orm/
├── shared/              # Common utilities and types
│   ├── types.ts        # FirestoreKey, FirestoreData, FirestoreValue, etc.
│   ├── utils.ts        # deepEqual, parseKey, buildPath, newId, timeId
│   └── async-queue.ts  # AsyncQueue for real-time updates
├── web/                # Client-side implementation (firebase/firestore)
│   ├── document.ts     # FirestoreDocument for web
│   ├── collection.ts   # FirestoreCollection for web
│   ├── query.ts        # buildQuery helper
│   ├── batch.ts        # batchSave, batchDelete
│   ├── firestore.ts    # Firestore singleton
│   ├── types.ts        # Web-specific type exports
│   └── index.ts        # Public API exports
├── admin/              # Server-side implementation (firebase-admin/firestore)
│   ├── document.ts     # FirestoreDocument for admin
│   ├── collection.ts   # FirestoreCollection for admin
│   ├── query.ts        # buildQuery helper
│   ├── batch.ts        # batchSave, batchDelete
│   ├── firestore.ts    # Firestore singleton
│   ├── types.ts        # Admin-specific type exports
│   └── index.ts        # Public API exports
├── test/               # Test files (not published to npm)
│   ├── admin/test.ts   # Admin SDK integration tests
│   ├── web/test.ts     # Web SDK integration tests
│   └── firebase.json   # Emulator configuration
└── dist/               # Compiled output (generated by tsc)
```

## Core Implementation

### 1. FirestoreDocument (ActiveRecord Pattern)

**Files**:
- [admin/document.ts](admin/document.ts) - Admin SDK implementation
- [web/document.ts](web/document.ts) - Web SDK implementation

**Key Features:**
- **CRUD Operations**: `get()`, `save()`, `set()`, `update()`, `delete()`
- **Change Tracking**: Proxy-based automatic dirty detection
- **Auto-generated IDs**: Optional automatic ID generation with `defaultKey`
- **Lifecycle Hooks**: Built-in validation and timestamp management with `beforeSave`/`afterSave`
- **Real-time Updates**: `watch()` and `snapshot()` for live data
- **Serialization**: Automatic Date ↔ Timestamp conversion
- **Transaction Support**: All methods support `Transaction` and `WriteBatch`
- **Path Templates**: Flexible path building with placeholders like `users/{uid}`

**Usage Example:**
```typescript
import { FirestoreDocument, FirestoreCollection, newId, timeId } from '@mizushino/firestore-orm/admin';

class User extends FirestoreDocument<UserKey, UserData> {
  protected static pathTemplate = 'users/{uid}';

  // Required: Define default data structure (use getter for dynamic values)
  protected static get defaultData(): UserData {
    return {
      name: '',
      email: '',
      age: 0,
    };
  }
}

// Basic usage with explicit key
const user = new User({ uid: 'user123' });
await user.get();
user.data.name = 'John';  // Change tracked via Proxy
await user.save();        // Only saves 'name' field (dirty tracking)

// Example 1: Auto-generate random IDs and timestamps using getters
class Post extends FirestoreDocument<PostKey, PostData> {
  protected static pathTemplate = 'posts/{postId}';

  protected static get defaultKey(): PostKey {
    return { postId: newId() };  // New ID generated each time
  }

  protected static get defaultData(): PostData {
    return {
      title: '',
      content: '',
      createdAt: new Date(),  // Fresh timestamp each time
    };
  }
}

const post = new Post();  // Auto-generates new postId
post.data.title = 'New Post';
await post.save();

// Example 2: Singleton pattern with fixed defaultKey
class AppConfig extends FirestoreDocument<AppConfigKey, AppConfigData> {
  protected static pathTemplate = 'config/{configId}';

  protected static get defaultKey(): AppConfigKey {
    return { configId: 'app-settings' };  // Always same document
  }

  protected static get defaultData(): AppConfigData {
    return {
      theme: 'light',
      language: 'en',
    };
  }
}

const config = new AppConfig();  // Always references 'app-settings'
await config.get();

// Example 3: Complete example with validation (from test/admin/test.ts)
interface UserKey extends FirestoreKey {
  uid: string;
}

interface UserData extends FirestoreData {
  name: string;
  email: string;
  age: number;
  createdAt: Date;
  updatedAt: Date;
}

class UserDocument extends FirestoreDocument<UserKey, UserData> {
  public static pathTemplate = 'users/{uid}';

  public static get defaultKey(): UserKey {
    return { uid: newId() };
  }

  public static get defaultData(): UserData {
    return {
      name: '',
      email: '',
      age: 0,
      createdAt: new Date(),
      updatedAt: new Date(),
    };
  }

  protected override beforeSave(): void {
    // Update timestamp on every save
    this.data.updatedAt = new Date();

    // Validation
    if (!this.data.name || this.data.name.trim() === '') {
      throw new Error('Name is required');
    }
    if (!this.data.email || !this.data.email.includes('@')) {
      throw new Error('Valid email is required');
    }
    if (this.data.age < 0) {
      throw new Error('Age must be non-negative');
    }
  }
}

// Create new user
const user = new UserDocument();
user.data.name = 'John Doe';
user.data.email = 'john@example.com';
user.data.age = 30;
await user.save();

// Collection class with inheritance pattern
class UserCollection extends FirestoreCollection<UserKey, UserData, UserDocument> {
  public static pathTemplate = 'users';
  public static documentClass = UserDocument;
}

// Query users
const users = new UserCollection(undefined, {
  where: [{ fieldPath: 'age', opStr: '>=', value: 18 }],
  orderBy: { fieldPath: 'age', directionStr: 'asc' },
  limit: 10
});
await users.get();

for (const [id, user] of users.documents) {
  console.log(`${id}: ${user.data.name} (${user.data.age})`);
}
```

**Key Properties:**
- `data` - Proxied data object with change tracking
- `key` - Document key object
- `id` - Document ID
- `exist` - Whether document exists in Firestore
- `isNew` - Whether document hasn't been saved yet
- `isDirty` - Whether document has unsaved changes
- `isLoaded` - Whether document has been loaded from Firestore
- `reference` - Firestore DocumentReference

**Important Methods:**
- `get(transaction?, cache?)` - Load from Firestore
- `save(force?, transaction?)` - Auto-detects set vs update
- `set(data?, transaction?)` - Overwrite entire document
- `update(transaction?)` - Update only changed fields
- `delete(transaction?)` - Delete document
- `watch(callback?)` - Real-time listener (returns unsubscribe function)
- `snapshot()` - AsyncGenerator for real-time updates
- `toObject()` - Get deep copy of data

**Lifecycle Hooks:**
- `beforeSave()` - Called before save/set/update
- `afterSave()` - Called after successful save

### 2. FirestoreCollection (Repository Pattern)

**Files**:
- [admin/collection.ts](admin/collection.ts) - Admin SDK implementation
- [web/collection.ts](web/collection.ts) - Web SDK implementation

**Key Features:**
- **Query Support**: Full Firestore query API via `Condition` interface
- **CRUD Operations**: `get()`, `add()`, `set()`, `delete()`
- **Document Management**: Map-based document cache
- **Real-time Updates**: `watch()` and `snapshot()`
- **Batch Operations**: Via separate `batchSave()` and `batchDelete()` functions

**Usage Example:**
```typescript
// Define Collection class
class UserCollection extends FirestoreCollection<UserKey, UserData, User> {
  protected static pathTemplate = 'users';
  protected static documentClass = User;
}

// Use the collection
const users = new UserCollection(undefined, {
  where: [{ fieldPath: 'age', opStr: '>=', value: 20 }],
  orderBy: { fieldPath: 'age', directionStr: 'asc' },
  limit: 10
});

await users.get();
for (const [id, user] of users.documents) {
  console.log(user.data);
}

// For subcollections with keys
class PostCollection extends FirestoreCollection<PostKey, PostData, Post> {
  protected static pathTemplate = 'users/{userId}/posts';
  protected static documentClass = Post;
}

const userPosts = new PostCollection({ userId: 'user123' });
await userPosts.get();
```

**Static Properties:**
- `pathTemplate` - Path template for building collection paths (e.g., 'users' or 'users/{userId}/posts')
- `documentClass` - Document class constructor (required for inheritance pattern)

**Key Properties:**
- `documents` - Map<string, Document> of loaded documents
- `reference` - Firestore CollectionReference
- `key` - Collection key (string array)
- `condition` - Query conditions
- `isLoaded` - Whether collection has been loaded

**Important Methods:**
- `get(cache?)` - Load documents matching query
- `add(data?, transaction?)` - Create document with auto-generated ID
- `set(id, data, transaction?)` - Create/update document with specific ID
- `delete(id, transaction?)` - Delete document by ID
- `save(transaction?)` - Save all dirty documents
- `first()` - Get first document
- `find(id)` - Find document by ID (cache only)
- `toArray()` - Convert documents to array
- `docs(force?)` - Get all documents as array
- `watch(callback)` - Real-time listener
- `unwatch()` - Cancel all listeners
- `snapshot()` - AsyncGenerator for real-time updates

### 3. Query Builder

**Files**:
- [admin/query.ts](admin/query.ts)
- [web/query.ts](web/query.ts)

**Condition Interface:**
```typescript
interface Condition {
  where?: Array<{
    fieldPath: string | FieldPath;
    opStr: WhereFilterOp;  // '==', '!=', '<', '<=', '>', '>=', 'array-contains', 'in', etc.
    value: unknown;
  }>;
  orderBy?: {
    fieldPath: string | FieldPath;
    directionStr?: 'asc' | 'desc';
  };
  limit?: number;
  limitToLast?: number;
  startAfter?: DocumentSnapshot;
  startAt?: DocumentSnapshot;
  endBefore?: DocumentSnapshot;
  endAt?: DocumentSnapshot;
}
```

### 4. Batch Operations

**Files**:
- [admin/batch.ts](admin/batch.ts)
- [web/batch.ts](web/batch.ts)

Batch operations are standalone functions that automatically chunk documents into batches of 500 (Firestore's limit):

```typescript
import { batchSave, batchDelete } from 'firestore-orm/admin';

// Save up to 1000s of documents
await batchSave([user1, user2, user3, /* ... */]);

// Delete multiple documents
await batchDelete([user1, user2, user3]);
```

### 5. Utility Functions

**File**: [shared/utils.ts](shared/utils.ts)

- `deepEqual(a, b)` - Deep equality comparison
- `parseKey(path, pathTemplate?)` - Parse Firestore path into key object
- `buildPath(key, pathTemplate?)` - Build Firestore path from key
- `newId(n?)` - Generate random alphanumeric ID
- `timeId(n?)` - Generate time-based sortable ID

### 6. AsyncQueue

**File**: [shared/async-queue.ts](shared/async-queue.ts)

Used internally for managing real-time snapshot streams in `snapshot()` AsyncGenerator methods.

## Design Considerations

### 1. Proxy-based Change Tracking

**Implementation**: Document data is wrapped in a Proxy that intercepts all property access and modifications.

**Benefits**:
- Automatic dirty tracking without manual marking
- Only changed fields are sent to Firestore on `save()`
- Clean API - developers don't need to think about change tracking

**Considerations**:
- Small performance overhead (negligible in practice)
- Nested objects are also proxied recursively

### 2. Path Templates

**Pattern**: `'users/{userId}/posts/{postId}'`

**Benefits**:
- Type-safe path construction
- Automatic path parsing and building
- Support for nested subcollections

**Implementation**:
- `buildPath()` replaces `{field}` placeholders with key values
- `parseKey()` extracts key fields from paths
- Validation ensures all required fields are present

### 3. Real-time Updates

**Two APIs**:
1. **`watch(callback)`** - Traditional callback-based listener
2. **`snapshot()`** - Modern AsyncGenerator for `for await` loops

**Memory Management**:
- `unwatch()` cancels all active listeners
- AsyncQueue handles cleanup on generator exit
- No memory leaks from forgotten listeners

### 4. Transaction & Batch Support

**All write operations accept optional `transaction` or `batch` parameters:**

```typescript
import { runTransaction } from 'firebase-admin/firestore';

await runTransaction(firestore(), async (transaction) => {
  const user = new User({ uid: 'user1' });
  await user.get(transaction);

  user.data.balance -= 100;
  await user.save(false, transaction);
});
```

### 5. Serialization

**Automatic conversions**:
- `Date` → `Timestamp` when writing
- `Timestamp` → `Date` when reading
- Nested objects handled recursively

**Customization via hooks**:
- Override `serializeValue()` for custom serialization
- Override `unserializeValue()` for custom deserialization

## Development Workflow

### Running Tests

1. **Start Firestore Emulator** (in one terminal):
```bash
npm run emulator
```

2. **Run Tests** (in another terminal):
```bash
npm run test:admin
npm run test:web
```

### Building

```bash
npm run build   # Compile TypeScript
npm run clean   # Remove dist/
```

### Publishing

```bash
npm version patch  # or minor/major
npm publish
```

## Tips for AI Assistants

When working with this codebase:

1. **File structure**: `admin/` and `web/` have parallel implementations
2. **Type safety**: Always use `interface` (not `type`) for Key and Data definitions - extends `FirestoreKey` and `FirestoreData`
3. **Type generics**: Always use proper generics `<Key, Data, Document>`
4. **Path templates**: Use `{field}` syntax, not `:field` or other formats
5. **defaultData**: Required static getter on all Document classes - use getter for dynamic values like `new Date()`
6. **defaultKey**: Optional static getter for auto-initialization when no key is provided to constructor - use getter for dynamic IDs like `newId()` or `timeId()`
7. **Validation**: Implement `beforeSave()` hook for validation and auto-updating timestamps (like `updatedAt`)
8. **Collection inheritance pattern**:
   - Define `pathTemplate` and `documentClass` as `public static` properties in subclasses
   - Constructor signature: `new UserCollection(key?, condition?)`
9. **Batch limit**: Firestore has 500-document batch limit (handled automatically)
10. **instanceof issue**: When testing locally with `file:../..` dependencies, `instanceof DocumentReference` may fail due to module duplication. Use duck typing or ensure proper module resolution.

## References

### Important Files

- Core types: [shared/types.ts](shared/types.ts)
- Utils: [shared/utils.ts](shared/utils.ts) - `newId()`, `timeId()`, `deepEqual()`, etc.
- Admin Document: [admin/document.ts](admin/document.ts)
- Admin Collection: [admin/collection.ts](admin/collection.ts)
- Web Document: [web/document.ts](web/document.ts)
- Web Collection: [web/collection.ts](web/collection.ts)
- Admin tests: [test/admin/test.ts](test/admin/test.ts) - Full integration test examples
- Web tests: [test/web/test.ts](test/web/test.ts) - Full integration test examples

### External Resources

- [Firestore Documentation](https://firebase.google.com/docs/firestore)
- [TypeScript Handbook](https://www.typescriptlang.org/docs/)
- [firebase npm package](https://www.npmjs.com/package/firebase)
- [firebase-admin npm package](https://www.npmjs.com/package/firebase-admin)
